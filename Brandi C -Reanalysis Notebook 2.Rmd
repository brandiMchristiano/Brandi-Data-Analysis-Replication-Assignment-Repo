---
title: "Brandi C- Reanalysis Notebook 2"
author: "BMC"
date: "4/14/2021"
output: html_document
---


# Getting Started 


```{r}
# Read in data from RData set

# I somehow have to get my data in to knit it 
load("new_bonds_data.RData")
head(dyads)
head(events)
head(rates)
head(trials)
```


```{r}
# Load Packages Used 
library(sna)
library(tidyverse)
library(boot)
library(lme4)
library(lmerTest)
library(gridExtra)
library(asnipe)
library(cowplot)
library(MuMIn)
library(ggplot2)
library(mosaic)
```


```{r}
# Set cowplot as theme
theme_set(theme_cowplot())
```

# Descriptive Statistical Analysis

## 41 bats were used in this study
```{r}
# Number of bats 
# Each bat is used as a receiver and an actor therefore either of these would suffice
length(unique(dyads[,2])) # Here I count the length of unique individuals in the 2nd column of the Dyads dataframe
length(unique(dyads[,1]))

```

## Bats were captured from two different sites in Panama : Tole and Las Pavas

### I had to filter by actor becasue the actors were only listed once and were compared to each reciever
```{r}
# Filtering from the Dyads dataframe, actor population
# Number of bats captured from Tole 
length(unique(dyads[,1][which(dyads$a.pop=="tole")])) # Here I count the length of unique individuals in the 1st column of the Dyads dataframe where the actor population (a.pop) is Tole
# 19 bats were captured from Tole
```
```{r}
# Number of bats captured from Las Pavas
length(unique(dyads[,1][which(dyads$a.pop=="las.pavas")])) # Here I count the length of unique individuals in the 1st column of the Dyads dataframe where the actor population (a.pop) is Las Pavas
# 8 bats were captured from Las Pavas
```

## The remaining 14 bats were captive born bats 
```{r}
length(unique(dyads[,1][which(dyads$a.pop=="captive-born")]))# Here I count the length of unique individuals in the 1st column of the Dyads dataframe where the actor population (a.pop) is captive born
```

## There were 1,214 possible new relationships among all the bats
```{r}
length(unique(dyads[,3][which(dyads$new.dyad)])) # Filters through the Dyads dataframe and picks out dyads from the 3rd column (the directed dyad column) where the relationship between the two individuals is a new paring (new.dyad=TRUE). A directed dyad is one in which the researchers purposefully paired two individuals together. 
```
# Possibile grooming rate versus Actual grooming rates
```{r}
# Possible grooming rates
groom.rate1 <- nrow(rates %>%  #Counting the number of rows after filtering the Rates dataframe for any behavior marked as grooming ("g")
  filter(behav=="g"))
groom.rate1
# There 32,928 possible grooming opportunities

# Actual grooming rates
groom.rate2 <- nrow(rates %>% # Counting the number of rows after filtering the Rates dataframe for any behavior marked as grooming ("g") that is greater than 0
  filter(behav=="g") %>% 
  filter(rate>0)) 
groom.rate2
# Grooming actually occurred 3,056 times


# Probability of two bats grooming each other in a trial
groom.rate3 <- groom.rate2/groom.rate1 # observed / expected
groom.rate3

```

## There are 17,621 chances for a bat to recieve a donation
```{r}
feed.pos <- nrow(rates %>% filter(behav=="f"))  # Filters the Rates dataframe and counts the number of rows where the behavior is feeding ("f")
feed.pos
```
## However, during trial, only 668 bats donated food to another bat
```{r}
feed.act <- nrow(rates %>% filter(behav=="f") %>% filter(rate>0))# Filters the Rates dataframe and counts the number of rows where the behavior is feeding ("f") but the rate is greater than 0, suggesting that a bat is sharing its food. 
feed.act
```
## There is a 3.8% probability that an individual will donate its food to another individual. This is not taking into account any type of relationship or association. 
```{r}
feed.probability <- feed.act/feed.pos # observed / expected
feed.probability

```


## How much time did it take for two unfamilar individuals to share food with one another

```{r}
time.to.share <- pull( # Pulls all the values that match the filter restrictions
  rates %>%  # Filtering through the Rates dataframe
  filter(behav=="f") %>% # filters for feeding behavior
  filter(new.dyad) %>% # we are only interested in unfamiliar individual interactions so this filters through only the new dyads
  filter(rate>0) %>% # filters through where the feeding rate is greater than 0 because that is when individuals are sharing
  group_by(undir.dyad) %>% # grouping by dyads that the researchers did not purposely create. This is showing the randomness of the sharing
  summarize(time.to.share= min(days.together))) # after filtering through all those variables, this summarizes all the conditions by the days the individuals spent together
mean(time.to.share) # on average, it took two unfamilar individuals 213 days to share food with one another
hist((time.to.share), main="Time it Took Unfamilar Individuals to Share Food with Eachother", breaks=50)
```

```{r}
# Does the same thing as before except this filters for grooming behavior
time.to.groom <- pull(
  rates %>%  
  filter(behav=="g") %>%
  filter(new.dyad) %>% 
  filter(rate>0) %>% 
  group_by(undir.dyad) %>% 
  summarize(time.to.groom= min(days.together)))
mean(time.to.groom)# on average, it took two unfamilar individuals 189 days to groom one another
hist((time.to.groom), main="Time it Took Unfamilar Individuals to Groonm Eachother", breaks=50)
```


```{r}
# To find the confidence intervals of the mean of these events, they boot strapped 10000 samples. The CIs I found are not ones included in the report. I ust did this as part of my descriptive stats portion

n_boot <- 10000
boot <- vector(length = n_boot) # set up a dummy variable to hold simulations
n <- length(time.to.share) 
for (i in 1:10000) {
  boot[[i]] <- mean(sample(time.to.share, n, replace = TRUE))
}

hist(boot,
  breaks = 20, xlab = "Mean",
  main = "Bootstrapped Sampling Distribution of Time to Share"
)
```

```{r}

stat <- function(data, indices) {
  return(mean(data[indices]))
}
results <- boot(data =time.to.share,statistic=stat,R = n_boot)
results

lower_boot <- quantile(results$t, 0.025)
lower_boot
upper_boot <- quantile(results$t, 0.975)
upper_boot

ci <- cbind(lower_boot,upper_boot)
ci

mean(results$t) # Th bootstrapped mean it took for individuals to share food is 212 days. The actual mean was 213 days
```

```{r}
plot1 <- (boxplot((results$t), main= "Time Until First New Sharing"))
```

```{r}
# CI of Time Until First Grooming
n_boot <- 10000
boot <- vector(length = n_boot) # set up a dummy variable to hold our simulations
n <- length(time.to.groom)
for (i in 1:10000) {
  boot[[i]] <- mean(sample(time.to.groom, n, replace = TRUE))
}

hist(boot,
  breaks = 20, xlab = "Mean",
  main = "Bootstrapped Sampling Distribution of Time to Groom"
)
stat <- function(data, indices) {
  return(mean(data[indices]))
}
results2 <- boot(data =time.to.groom,statistic=stat,R = n_boot)
results2


lower_boot <- quantile(results2$t, 0.025)
lower_boot
upper_boot <- quantile(results2$t, 0.975)
upper_boot
ci <- cbind(lower_boot, upper_boot)
ci

mean(results2$t) # The bootstrapped mean time it took for individuals to groom each other was 188 days. The actual mean was 189 days. 
boxplot((results2$t), main= "Time Until First Grooming")
```


```{r}
# Comparison of the two
par(mfrow = c(1, 2))
boxplot((results2$t),main="Time Until First Grooming")
boxplot((results$t), main = "Time Until First Food Sharing")
```


```{r}
(pop_stats1 <- favstats(~time.to.groom, data = dyads))
(pop_stats2 <- favstats(~time.to.share, data = dyads))
(pop_stats3 <- favstats(~rate, data = rates))
(pop_stats4 <- favstats(~rate2, data = rates))

```



```{r}

# Time until first grooming session in the small groups
timeuntilgroomSmall <- 
  rates %>% 
  filter(new.dyad) %>%
  filter(adult.dyad) %>% 
  filter(behav=="g") %>% 
  #filter(behav=="f") %>% 
  filter(rate>0) %>% 
  filter(period=="small cages") %>% 
  group_by(dir.dyad) %>% 
  summarize(latency=min(days.together)+1) %>% 
  mutate(association= "forced")

timeuntilgroomBig <- 
  rates %>% 
  filter(new.dyad) %>%
  filter(adult.dyad) %>% 
  filter(behav=="g") %>% 
  #filter(behav=="f") %>% 
  filter(rate>0) %>% 
  filter(period=="big cage") %>% 
  group_by(dir.dyad) %>% 
  summarize(latency=min(days.together)+1) %>% 
  mutate(association= "free")
mean(timeuntilgroomBig$latency)# They found that the mean of time before initial introductions and when the first grooming interaction occured was 146 days
latency <- 
  rbind(timeuntilgroomSmall, timeuntilgroomBig) %>% 
  arrange(dir.dyad, association) %>%
  group_by(dir.dyad) %>% 
  summarize(latency=min(latency), 
            association= min(association))
latency
rbind(timeuntilgroomSmall, timeuntilgroomBig) %>% 
  boot_ci2(y= .$latency, x=.$association)
# They found the confidence intervals of the latency difference between indivudlas in pairs versus quarlets to be 134 - 160. There were 187 relationships.
```


























# Data Visualization 

```{r} 
# Figure 2 part 1
fig2.1 <- rates %>% 
  filter(behav=="g") %>%
   filter(new.dyad) %>%
  filter(period== "big cage") %>% # this is when they were in groups with unfamilar individuals
  filter(!is.na(sharing.colony)) %>% # makes non NA into true values
  filter(before.first.donation | is.na(before.first.donation)) %>% 
  mutate(rate3= (rev.groom.rate>0)*1) %>% 
  ggplot(aes(x=date,y=rate3, group=sharing))+
  geom_smooth(method = "glm", method.args = list(family = "binomial"))+xlab("time")+ylab("probability of being groomed in a trial (before first donation")

fig2.1

```


```{r}
fig2.2<- rates %>% 
  filter(behav=="g") %>%
  filter(new.dyad) %>%
  filter(period== "big cage") %>%
  filter(adult.dyad) %>%
  filter(!is.na(sharing)) %>% # filter out everything that is not NA in sharing ... aka everything that is sharing
  filter(before.first.donation |is.na(before.first.donation)) %>% 
  mutate(rate3= (rev.groom.rate2>0)*1) %>% 
  ggplot(aes(date,rate3, group=sharing))+
  geom_smooth(method = "glm", method.args = list(family = "binomial"))+ # Authors state they used generalized linear models (glm)
  xlab("time")
fig2.2

# I don't really understand how to change the dashed and solid lines. The dashed line should represent individuals not sharing
```

```{r}
fig2.3 <- rates %>% 
   filter(behav=="g") %>%
  filter(new.dyad) %>% 
  filter(period== "big cage") %>%
   filter(!adult.dyad) %>% # looking at new young adults so filter out everything that's not an established adult dyad. 
  filter(!is.na(sharing)) %>% 
  filter(before.first.donation | is.na(before.first.donation)) %>% 
  mutate(rate3= (rev.groom.rate>0)*1) %>% 
  ggplot(aes(x=date,y=rate3, group=sharing))+
  geom_smooth(method = "glm",method.args = list(family = "binomial"))+ # showing the standard errors 
  ylab("probability of being groomed in a trial (before first donation)")+
  xlab("time")

fig2.3

# Once I figured out what was going on in the first plot, the other two were easier tp recreate. They were exactly the same but with an additional filter.
```
```{r}
grid.arrange(fig2.1, fig2.2, fig2.3, ncol=3)
```






# Infrenetial Statistical Analysis

## Create a data frame that filters out Tole bats that are in the mixed group 
## Filter by feeding behavior
```{r}
feedingbehavTole <- as.data.frame(
  rates %>% 
  filter(behav=="f") %>% #Filters for feeding behavior
  filter(a.pop== "tole") %>% # Filters for actor population to be Tole
  filter(adult.dyad) %>% # Only using adult dyads
  filter(period== "big cage") %>% # Looking at bats in the big cage quartlets
  filter(!is.na(sharing.colony)) %>% # Filters out everything that is not an NA sharing
  mutate(samepop= a.pop==r.pop) %>% # mutates the two populations to be one population
  group_by(actor, dir.dyad, samepop) %>% # grouping by actor just  to have one subset of the data
  summarise(rate=mean(rate2))) # Making a rate variable that is just the mean of the second Rate column 
feedingbehavTole
```


```{r}
perms <- 10000
fit <- summary(lm(rate~samepop, data=feedingbehavTole))
fit
# B=0.09, p=0.03, n=390
#I got the same beta value of 0.09. I did not get the same p value, however, both are significant. Carter et al. got a p value of 0.003 and I got a p value of 0.03... which is pretty close. 

```



```{r}
# same process as previous but this time I do it for grooming behavior
groomingbehavTole <- as.data.frame(
  rates %>% 
  filter(adult.dyad) %>% 
  filter(period== "big cage") %>%
  filter(behav=="g") %>%
  filter(a.pop== "tole") %>% 
  filter(!is.na(sharing.colony)) %>% 
  mutate(samepop2= a.pop==r.pop) %>%
  group_by(actor, dir.dyad, samepop2) %>% 
  summarise(rate=mean(rate2)))
groomingbehavTole
```
```{r}
perms <- 10000
fit2 <- summary(lm(rate~samepop2, data=groomingbehavTole))
fit2
nrow(groomingbehavTole)
# B = 0.103 , p=0.14, n=390
```



```{r} 
# Same process as before but for Las Pava bats
feedingbehavPavas <- as.data.frame(
  rates %>% 
  filter(behav=="f") %>%
  filter(a.pop== "las.pavas") %>% 
  filter(adult.dyad) %>% 
  filter(period== "big cage") %>%
  filter(!is.na(sharing.colony)) %>% 
  mutate(samepop= a.pop==r.pop) %>%
  group_by(actor, dir.dyad, samepop) %>% 
  summarise(rate=mean(rate2)))
feedingbehavPavas
```

```{r}
perms <- 10000
fit3 <- summary(lm(rate~samepop, data=feedingbehavPavas))
fit3
nrow(groomingbehavTole)
nrow(feedingbehavPavas)
# B=0.28, p=0.0001, n=160
```

```{r}
groomingbehavPavas <- as.data.frame(
  rates %>% 
  filter(behav=="g") %>%
  filter(a.pop== "las.pavas") %>% 
  filter(adult.dyad) %>% 
  filter(period== "big cage") %>%
  filter(!is.na(sharing.colony)) %>% 
  mutate(samepop= a.pop==r.pop) %>%
  group_by(actor, dir.dyad, samepop) %>% 
  summarise(rate=mean(rate2)))
groomingbehavPavas
```

```{r}
perms <- 10000
fit4 <- summary(lm(rate~samepop, data=groomingbehavPavas))
fit4
nrow(groomingbehavPavas)
# B=0.53, p<0.0001, n=160
```


